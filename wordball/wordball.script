local flow = require "ludobits.m.flow"
local words = require "wordball.words"


local function post_to_ui(message_id, message)
	msg.post("ui#wordball", message_id, message)
end

local function feedback(text)
	print("feedback", text)
	label.set_text("feedback#label", text)
	go.set_position(vmath.vector3(320, -200, 0), "feedback")
	go.animate("feedback", "position.y", go.PLAYBACK_ONCE_FORWARD, 568, go.EASING_OUTQUAD, 1, 0, function()
		go.set_position(vmath.vector3(320, -200, 0), "feedback")
	end)
end


local function highlight_ball(self, id, enable)
	msg.post(msg.url(nil, id, "highlight"), enable and "enable" or "disable")
end


local function spawn_ball(self, letter)
	local id = factory.create("factories#ball", vmath.vector3(math.random(40,600), 1300, 0), nil, {}, 0.6)
	letter = letter or words.random_letter()
	value = words.value(letter)
	label.set_text(msg.url(nil, id, "letter"), letter)
	label.set_text(msg.url(nil, id, "value"), value)
	highlight_ball(self, id, false)
	self.letters[id] = { letter = letter, selected = false, id = id }
	--print(self.letters[id])
end

local function add_letter_to_word(self, letter_to_add)
	letter_to_add.selected = true
	go.set(msg.url(nil, letter_to_add.id, "bg"), "tint.w", 4)
	table.insert(self.word, letter_to_add)
end

local function remove_letter_from_word(self, letter_to_remove)
	for i,letter in ipairs(self.word) do
		if letter.id == letter_to_remove.id then
			go.set(msg.url(nil, letter_to_remove.id, "bg"), "tint.w", 1)
			letter_to_remove.selected = false
			table.remove(self.word, i)
			break
		end
	end
end


local function update_score(self)
	post_to_ui("update_score", { score = self.score, max = 100 })
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "clear_color", { color = vmath.vector4(0.1, 0.1, 0.1, 1.0) })
	words.load("en")
	math.randomseed(os.time())
	self.letters = {}
	self.word = {}
	self.score = 0
	update_score(self)
	flow(function()
		for i=1,10 do
			spawn_ball(self)
			flow.delay(0.1)
		end
		while true do
			spawn_ball(self)
			flow.delay(2)
		end
	end)
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	flow.update(dt)
end

function on_message(self, message_id, message, sender)
	flow.on_message(message_id, message, sender)
	if message_id == hash("cursor_over") then
		highlight_ball(self, message.id, true)
	elseif message_id == hash("cursor_out") then
		highlight_ball(self, message.id, false)
	elseif message_id == hash("released") then
		local l = self.letters[message.id]
		if not l.selected then
			add_letter_to_word(self,l)
		else
			remove_letter_from_word(self, l)
		end
		post_to_ui("word", self.word )
	elseif message_id == hash("add_letters") then
		for i=1,#message.letters do
			spawn_ball(self, message.letters:sub(i,i))
		end
	elseif message_id == hash("cancel_word") then
		while #self.word > 0 do
			remove_letter_from_word(self, self.word[1])
		end
	elseif message_id == hash("wrong_word") then
		feedback("WRONG!")
		while #self.word > 0 do
			remove_letter_from_word(self, self.word[1])
		end
		pprint(self.word)
	elseif message_id == hash("correct_word") then
		local value = message.value
		feedback("CORRECT!\n+" .. tostring(value) .. " pts")
		self.score = self.score + value
		update_score(self)
		for k,letter in pairs(self.word) do
			self.word[k] = nil
			go.delete(letter.id)
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
