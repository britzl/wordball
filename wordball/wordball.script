local flow = require "ludobits.m.flow"
local words = require "wordball.words"
local camera = require "orthographic.camera"

local SELECTED = vmath.vector4(1, 1, 1, 4)
local BONUS = vmath.vector4(1.5, 0.5, 0, 2.5)
local NORMAL = vmath.vector4(1)
local LOCKED = vmath.vector4(0.4, 0.4, 0.4, 1)

local function post_to_ui(message_id, message)
	msg.post("ui#wordball", message_id, message)
end

local function tint_letter(letter, tint)
	tint = tint or vmath.vector4(0)
	local tint_mul = vmath.vector4(letter.tint.x + tint.x, letter.tint.y + tint.y, letter.tint.z + tint.z, letter.tint.w + tint.w)
	go.set(msg.url(nil, letter.id, "bg"), "tint", tint_mul)
end

local function one_in_x(chance)
	assert(chance and type(chance) == "number" and chance >= 1)
	return math.random(1, chance) == chance
end

local function feedback(text)
	print("feedback", text)
	label.set_text("feedback#label", text)
	go.set_position(vmath.vector3(320, -200, 0), "feedback")
	go.animate("feedback", "position.y", go.PLAYBACK_ONCE_FORWARD, 568, go.EASING_OUTQUAD, 1, 0, function()
		go.set_position(vmath.vector3(320, -200, 0), "feedback")
	end)
end

local function highlight_ball(self, id, enable)
	msg.post(msg.url(nil, id, "highlight"), enable and "enable" or "disable")
end

local function spawn_ball(self, letter)
	local bonus = one_in_x(10)
	local tint = bonus and BONUS or NORMAL
	local id = factory.create("factories#ball", vmath.vector3(math.random(40,600), 1300, 0), nil, {}, 0.6)
	letter = letter or words.random_letter()
	value = words.value(letter)
	if bonus then
		value = value + 25
	end
	label.set_text(msg.url(nil, id, "letter"), letter)
	label.set_text(msg.url(nil, id, "value"), value)
	highlight_ball(self, id, false)
	self.letters[id] = { letter = letter, selected = false, id = id, tint = tint, bonus = bonus, value = value }
	tint_letter(self.letters[id])
end

local function add_letter_to_word(self, letter_to_add)
	letter_to_add.selected = true
	tint_letter(letter_to_add, SELECTED)
	--go.set(msg.url(nil, letter_to_add.id, "bg"), "tint.w", 4)
	table.insert(self.word, letter_to_add)
end

local function remove_letter_from_word(self, letter_to_remove)
	for i,letter in ipairs(self.word) do
		if letter.id == letter_to_remove.id then
			tint_letter(letter_to_remove)
			--go.set(msg.url(nil, letter_to_remove.id, "bg"), "tint.w", 1)
			letter_to_remove.selected = false
			table.remove(self.word, i)
			break
		end
	end
end

local function delete_word(self)
	for k,letter in pairs(self.word) do
		self.word[k] = nil
		go.delete(letter.id)
	end
end

local function reset_word(self)
	while #self.word > 0 do
		remove_letter_from_word(self, self.word[1])
	end
end

local function reset_and_lock_word(self)
	while #self.word > 0 do
		local letter = self.word[1]
		remove_letter_from_word(self, letter)
		letter.tint = LOCKED
		tint_letter(letter)
		msg.post(msg.url(nil, letter.id, "cursor"), "disable")
		msg.post(msg.url(nil, letter.id, "letter"), "disable")
		msg.post(msg.url(nil, letter.id, "value"), "disable")
	end
end

local function update_score(self)
	post_to_ui("update_score", { score = self.score, max = 100 })
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "clear_color", { color = vmath.vector4(0.1, 0.1, 0.1, 1.0) })
	words.load("en")
	math.randomseed(os.time())
	self.letters = {}
	self.word = {}
	self.score = 0
	update_score(self)
	flow(function()
		for i=1,10 do
			spawn_ball(self)
			flow.delay(0.1)
		end
		while true do
			spawn_ball(self)
			flow.delay(2)
		end
	end)
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	flow.update(dt)
end

function on_message(self, message_id, message, sender)
	flow.on_message(message_id, message, sender)
	if message_id == hash("cursor_over") then
		highlight_ball(self, message.id, true)
	elseif message_id == hash("cursor_out") then
		highlight_ball(self, message.id, false)
	elseif message_id == hash("released") then
		local l = self.letters[message.id]
		if not l.selected then
			add_letter_to_word(self,l)
		else
			remove_letter_from_word(self, l)
		end
		post_to_ui("word", { letters = self.word } )
	elseif message_id == hash("add_letters") then
		for i=1,#message.letters do
			spawn_ball(self, message.letters:sub(i,i))
		end
	elseif message_id == hash("cancel_word") then
		reset_word(self)
	elseif message_id == hash("wrong_word") then
		feedback("WRONG!")
		reset_and_lock_word(self)
	elseif message_id == hash("correct_word") then
		local value = message.value
		feedback("CORRECT!\n+" .. tostring(value) .. " pts")
		self.score = self.score + value
		update_score(self)
		delete_word(self)
	end
end

function on_input(self, action_id, action)
	local screen = vmath.vector3(action.x, action.y, 0)
	local world = camera.screen_to_world(hash("/camera"), screen)
	action.x = world.x
	action.y = world.y
	msg.post("#cursor", "input", { action_id = action_id, action = action })
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
